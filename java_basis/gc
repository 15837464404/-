1.gc:java垃圾回收机制，有jvm自动在需要的时候自动完成，当gc后扔没有足够的空间给新创建的对象使用时会抛oom异常。
2.gc把java堆划分为新生代（Eden）和老年代。新生代发生的gc称为Minor GC.full gc 回收整个堆。
3.gc算法：标记清除（回收后内存空间是不连续的）， 复制算法（不能使用全部内存。）， 标记整理（回收后内存空间是连续的）
4.对象是否可回收算法： 引用计数 （循环依赖无法回收），可达性分析算法：选举一个根节点，从根节点开始遍历，当一个对象没有到根节点上的引用时即可以被回收。
  java中适合做根节点的对象：1，虚拟机栈中引用的对象，2，方法区中静态属性引用的对象，3，方法区中常量引用的对象，4，本地方法栈中JNI(即一般说的Native方法)
  引用的对象。
5.finalize（）方法：在可达性分析算法中不可达的对象并非是非死不可的，要真正宣告一个对象死亡至少要经历两次标记过程，当经过第一次标记后，会查看这个对象是否
  有必要之行finalize（）方法，如果对象没有覆盖finalize（）方法或者finalize（）方法已经被调用过，则该对象可以被回收。如果需要执行finalize（）方法，
  那么这个对象会被放进F-Queue队列中，并稍后由一个由虚拟机自动创建的，低优先级的Finalize线程执行该队列。虚拟机只会触发该方法，并不保证该方法一定执行
  完成。原因是因为如果一个对象的finalize（）方法死循环将会导致队列中的其它对象都处于永久等待，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃
  脱死亡的最后一个机会，稍后gc会对F－Queue进行第二次小规模标记。如果还没逃脱，就可以被回收。
6.HotSpot的gc算法实现：通过枚举根节点进行gc ，为了避免扫描整个堆，jvm使用OopMap的数据结构来得知那些地方存放着对象引用。
7.安全点：jvm并不会在任何时间点停顿发生gc，只会在进入安全点后执行gc，一般 方法调用，循环跳转，异常跳转 等会产生安全点。但是当线程处于sleep时是无法进入 
  安全点的，因此有了安全区域的概念。 安全区域：指在一段代码片段中，引用关系不会发生变化，在这个区域的任何地方发生gc都是安全的。
8.jvm提供的垃圾回收器

  新生代（Eden）：Serial ，ParNew  ，Parallel Scavenge。
  老年代：CMS ，Serial Old ，Parallel Old 。
  不区分代的：G1
  
  
  
  Serial ：最古老的收集器， 单线程串行收集 STW ，client模式下的默认收集器。 可与cms合用。
  ParNew： Serial 的多线程版本。可与cms合用。
  Parallel Scavenge：使用复制算法的并行收集器，吞吐量优先的gc收集器。可与Parallel Old合用。
  以上三者都可以与Serial Old合用。
  
  Serial Old：单线程收集器，使用标记整理算法。主要意义给clint模式下的jvm使用。另一种用途是cms的后备预案（server模式下）。
  Parallel Old：多线程，使用标记整理算法。
  CMS：停顿时间优先，适合希望系统停顿时间最短的应用。使用标记清除算法实现，整个过程分为4个步骤。包括：
    1.初始标记。
    2.并发标记。
    3.重新标记。
    4.并发清除。
    其中，初始标记和重新标记仍需要stw。初始标记知标记根节点能直接关联的对象。并发标记是进行GC Roots Tracing 的过程，重新标记是为了修正并发标记期间
    因程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记要长，但远比并发标记时间短。
    
    cms的缺点： 
      1.对cpu资源非常敏感。cms默认启动的线程数是（cpu num ＋ 3） ／ 4 。
      2.cms无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次full gc的产生。由于cms并发清理阶段用户线程还在执行，这段时间产生的
      垃圾，cms无法在当次回收中处理，只好等待下次gc再处理，这部分垃圾称为浮动垃圾。
      3.cms是标记清除算法实现的，因此回收后会造成内存的不连续性。空间碎片过多但没有足够的空间分配对象时会触发full gc 。为解决这个问题，cms提供了一个
      -XX:+UseCMSCompactAtFullCollection开关参数（默认开启），在cms顶不住要进行full gc时开启内存碎片的合并整理过程。
      
    G1:
      1.并行与并发。
      2.分代收集，但不需要其它垃圾回收器配合。
      3.空间整合，g1从整体看是基于标记整理算法实现的，从局部（两个Region）看是基于复制算法实现的。
      4.可预测的停顿。
      分为以下4步：
      1.初始标记
      2.并发标记
      3.最终标记
      4.筛选回收
      
      G1把内存分为多个Region。跨Region的对象引用用Remembered Set来避免gc时的全堆扫描。
   
   
  
  
