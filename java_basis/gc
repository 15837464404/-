1.gc:java垃圾回收机制，有jvm自动在需要的时候自动完成，当gc后扔没有足够的空间给新创建的对象使用时会抛oom异常。
2.gc把java堆划分为新生代（Eden）和老年代。新生代发生的gc称为Minor GC.full gc 回收整个堆。
3.gc算法：标记清除（回收后内存空间是不连续的）， 复制算法（不能使用全部内存。）， 标记整理（回收后内存空间是连续的）
4.对象是否可回收算法： 引用计数 （循环依赖无法回收），可达性分析算法：选举一个根节点，从根节点开始遍历，当一个对象没有到根节点上的引用时即可以被回收。
  java中适合做根节点的对象：1，虚拟机栈中引用的对象，2，方法区中静态属性引用的对象，3，方法区中常量引用的对象，4，本地方法栈中JNI(即一般说的Native方法)
  引用的对象。
5.finalize（）方法：在可达性分析算法中不可达的对象并非是非死不可的，要真正宣告一个对象死亡至少要经历两次标记过程，当经过第一次标记后，会查看这个对象是否
  有必要之行finalize（）方法，如果对象没有覆盖finalize（）方法或者finalize（）方法已经被调用过，则该对象可以被回收。如果需要执行finalize（）方法，
  那么这个对象会被放进F-Queue队列中，并稍后由一个由虚拟机自动创建的，低优先级的Finalize线程执行该队列。虚拟机只会触发该方法，并不保证该方法一定执行
  完成。原因是因为如果一个对象的finalize（）方法死循环将会导致队列中的其它对象都处于永久等待，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃
  脱死亡的最后一个机会，稍后gc会对F－Queue进行第二次小规模标记。如果还没逃脱，就可以被回收。
6.HotSpot的gc算法实现：通过枚举根节点进行gc ，为了避免扫描整个堆，jvm使用OopMap的数据结构来得知那些地方存放着对象引用。
7.安全点：jvm并不会在任何时间点停顿发生gc，只会在进入安全点后执行gc，一般 方法调用，循环跳转，异常跳转 等会产生安全点。但是当线程处于sleep时是无法进入 
  安全点的，因此有了安全区域的概念。 安全区域：指在一段代码片段中，引用关系不会发生变化，在这个区域的任何地方发生gc都是安全的。
8.jvm提供的垃圾回收器

  新生代（Eden）：Serial ，ParNew  ，Parallel Scavenge。
  老年代：CMS ，Serial Old ，Parallel Old 。
  不区分代的：G1
  
  
  
  Serial ：最古老的收集器， 单线程串行收集 STW ，client模式下的默认收集器。 可与cms合用。
  ParNew： Serial 的多线程版本。可与cms合用。
  Parallel Scavenge：使用复制算法的并行收集器，吞吐量优先的gc收集器。可与Parallel Old合用。
  以上三者都可以与Serial Old合用。
  
  Serial Old：单线程收集器，使用标记整理算法。主要意义给clint模式下的jvm使用。另一种用途是cms的后备预案（server模式下）。
  Parallel Old：多线程，使用标记整理算法。
  CMS：停顿时间优先，适合希望系统停顿时间最短的应用。使用标记清除算法实现，整个过程分为4个步骤。包括：
    1.初始标记。
    2.并发标记。
    3.重新标记。
    4.并发清除。
    其中，初始标记和重新标记仍需要stw。初始标记知标记根节点能直接关联的对象。并发标记是进行GC Roots Tracing 的过程，重新标记是为了修正并发标记期间
    因程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记要长，但远比并发标记时间短。
    
    cms的缺点： 
      1.对cpu资源非常敏感。cms默认启动的线程数是（cpu num ＋ 3） ／ 4 。
      2.cms无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次full gc的产生。由于cms并发清理阶段用户线程还在执行，这段时间产生的
      垃圾，cms无法在当次回收中处理，只好等待下次gc再处理，这部分垃圾称为浮动垃圾。
      3.cms是标记清除算法实现的，因此回收后会造成内存的不连续性。空间碎片过多但没有足够的空间分配对象时会触发full gc 。为解决这个问题，cms提供了一个
      -XX:+UseCMSCompactAtFullCollection开关参数（默认开启），在cms顶不住要进行full gc时开启内存碎片的合并整理过程。
      
    G1:
      1.并行与并发。
      2.分代收集，但不需要其它垃圾回收器配合。
      3.空间整合，g1从整体看是基于标记整理算法实现的，从局部（两个Region）看是基于复制算法实现的。
      4.可预测的停顿。
      分为以下4步：
      1.初始标记
      2.并发标记
      3.最终标记
      4.筛选回收
      
      G1把内存分为多个Region。跨Region的对象引用用Remembered Set来避免gc时的全堆扫描。
      

打开gc日志：
多种方法都能开启 GC 的日志功能，其中包括:使用 -verbose:gc 或 -XX:+PrintGC 这两个标志中的任意一个能创建基本的 GC 日志
(这两个日志标志实际上互为别名，默认情况下 的 GC 日志功能是关闭的)。使用 -XX:+PrintGCDetails 标志会创建更详细的 GC 日志。
我 们推荐使用 -XX:+PrintGCDetails 标志(这个标志默认情况下也是关闭的);通常情况下使 用基本的 GC 日志很难诊断垃圾回收时发生的问题。
除了使用详细的 GC 日志，我们还推 荐使用 -XX:+PrintGCTimeStamps 或者 -XX:+PrintGCDateStamps，便于我们更精确地判断几 次 GC 操作之间的时间。
这两个参数之间的差别在于时间戳是相对于 0(依据 JVM 启动的 时间)的值，而日期戳(date stamp)是实际的日期字符串。由于日期戳需要进行格式化，
所以它的效率可能会受轻微的影响，不过这种操作并不频繁，它造成的影响也很难被我们 感知。
默认情况下 GC 日志直接输出到标准输出，不过使用 -Xloggc:filename 标志也能修改输出 到某个文件。除非显式地使用 -PrintGCDetails 标志，
否则使用 -Xloggc 会自动地开启基 本日志模式。使用日志循环(Log rotation)标志可以限制保存在 GC 日志中的数据量;对 于需要长时间运行的服务器而言，
这是一个非常有用的标志，否则累积几个月的数据很 可能会耗尽服务器的磁盘。
通过 -XX:+UseGCLogfileRotation -XX:NumberOfGCLogfiles=N -XX:GCLogfileSize=N 标志可以控制日志文件的循环。默认情况下，
UseGCLogfileRotation 标志是关闭的。开启 UseGCLogfileRotation 标志后，默认的文件数目是 0(意味着不作任 何限制)，
默认的日志文件大小是 0(同样也是不作任何限制)。因此，为了让日志循环功 能真正生效，我们必须为所有这些标志设定值。需要注意的是，
如果设定的数值不足 8 KB 的话，日志文件的大小会以 8 KB 为单位规整。
   
 cms参数设置 ：
 为了让 CMS 收集器赢得这场比赛，方法之一是更早地启动并发收集周期。显然地，CMS 收集器在老年代空间占用达到 60% 时启动并发周期，
 这和老年代空间占用到 70% 时才启 动相比，前者完成垃圾收集的几率更大。为了实现这种配置，最简单的方法是同时设置 下 面 这 两 个 标 志:
 -XX:CMSInitiatingOccupancyFraction=N 和 -XX:+UseCMSInitiatingOcc upancyOnly。 同时使用这两个参数能帮助 CMS 更容易地进行决策:
 如果同时设置这两个 标志，那么 CMS 就只依据设置的老年代空间占用率来决定何时启动后台线程。默认情况 下，UseCMSInitiatingOccupancyOnly 标志的值为假，
 CMS 会使用更复杂的算法判断什么 时候启动并行收集线程。如果有必要提前启动后台线程，推荐使用最简单的方法，
 即将 UseCMSInitiatingOccupancyOnly 标志的值设置为真。
CMSInitiatingOccupancyFraction 参数值的调整可能需要多次迭代才能确定。如果开启了 UseCMSInitiatingOccupancyOnly 标志，
CMSInitiatingOccupancyFraction 的默认值就被置 为 70，即 CMS 会在老年代空间占用达到 70% 时启动并发收集周期。
   
  
  
