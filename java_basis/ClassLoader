1.类从被加载到虚拟机中到被卸载的生命周期为：  加载 >连接>初始化 ，其中连接包括 验证，准备，解析

加载：将class文件（该文件可以从任何地方获取）读入方法区（jdk8已废弃方法区的概念，称之为metaspace）
验证：验证加载的文件是否符合虚拟机规范标准。
准备：给类变量分配默认值，如 
class Demo{
    public static int demo = 123
}
当准备阶段后，demo在方法区上的值为0 ，只有遇到putstatic指令后才会被分配成123，而如果是被final修饰的，如
class Demo{
    public static final int demo = 123
}
当准备阶段后，demo在方法区上的值为123。
解析：将虚拟机常量池内的符号引用替换为直接引用的过程。
符号引用：以CONSTANT_ 的形式出现，用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
直接引用：直接引用是可以直接指向目标的指针，相对偏移量或是一个能直接定位目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
初始化：java虚拟机明确规定有且只有5种情况对类进行初始化，
1.当遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没初始化必须对其进行初始化。
2.使用java.lang.reflect包的方法对类进行反射调用的时候。
3.当初始化一个类，发现其父类还没初始化时必须先初始化其父类。
4.当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
5.当使用jdk 1.7 的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

类加载器：
启动类加载器（bootstrap ClassLoader）：这个类加载器负责加载<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机所识别的类库加载到虚拟机内存中。该加载器无法被java程序直接引用。
扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用。
应用程序类加载器（Application ClassLoader）：这个加载器由sun.misc.Launcher$AppClassLoader实现，这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般称它为系统类加载器。它负责加载用户类路径（classpath）上所指定的类库，如果没有自定义类加载器，一般情况此为默认类加载器。


双亲委派机制：如果一个类加载器收到了类加载的请求，首先不会自己尝试加载这个类， 会把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有类加载请求都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

双亲委派机制确保类只会被加载一次。

以上内容摘抄自《深入理解java虚拟机第二版》第七章：虚拟机类加载机制
