time_wait :在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）
为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？
主要有两个原因：
1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，
2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。
你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》


Nagle算法
该算法要求一个 T C P 连 接 上 最 多 只 能 有 一 个 未 被 确 认 的 未 完 成 的 小 分 组 ， 在 该 分 组 的 确 认到达之前不能发送其他的小分组。
相反， T C P 收 集 这 些 少 量 的 分 组 ， 并 在 确 认 到 来 时 以 一 个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发 送得越快。
而在希望减少微小分组数目的低速广域网上，则会发送更少的分组(我们将在2 2 . 3 节 看 到 “ 小 ” 的 含 义 是 小 于 报 文 段 的 大 小 )。


慢启动
该 算 法 通 过 观 察 到 新 分 组 进入网络的速率应该与另一端返回确认的速率相同而进行工作。
慢 启 动 为 发 送 方 的 T C P 增 加 了 另 一 个 窗 口 : 拥 塞 窗 口 ( c o n g e s t i o n w i n d o w ) ，记为 c w n d。
当与另一个网络的主机建立 T C P 连接时，拥塞窗口被初始化为 1 个 报 文 段 ( 即 另 一 端 通 告 的 报 文 段 大 小 )。 每 收 到 一 个 A C K ，
拥 塞 窗 口 就 增 加 一 个 报 文 段 ( c w n d 以 字 节 为 单 位 ， 但 是 慢 启 动 以报文段大小为单位进行增加)。
发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥 塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。
发送方开始时发送一个报文段，然后等待 A C K 。当收到该 A C K 时，拥塞窗口从 1 增加为 2 ， 即 可 以 发 送 两 个 报 文 段 。
当 收 到 这 两 个 报 文 段 的 A C K时 ， 拥 塞 窗 口 就 增 加 为 4 。 这 是 一 种 指 数 增加的关系


对每个连接， T C P 管理 4 个不同的定时器
1) 重传定时器使用于当希望收到另一端的确认。
2) 坚持 ( p e r s i s t ) 定 时 器 使 窗 口 大 小 信 息 保 持 不 断 流 动 ， 即 使 另 一 端 关 闭 了 其 接 收 窗 口 。
3) 保活 ( k e e p a l i v e ) 定时器可检测到一个空闲连接的另一端何时崩溃或重启。
4) 2MSL定时器测量一个连接处于 TIME_WAIT状态的时间。


拥塞避免算法
该 算 法 假 定 由 于 分 组 受 到 损 坏 引 起 的 丢 失 是 非 常 少 的 ( 远 小 于 1 % )， 
因 此 分 组 丢 失 就 意 味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示:发生超时 和接收到重复的确认
拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希 望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。
在实际中这两个算法 通常在一起实现。
拥塞避免算法和慢启动算法需要对每个连接维持两个变量:一个拥塞窗口 c w n d和一个慢 启动门限 s s t h re s h 。这样得到的算法的工作过程如下:
1) 对一个给定的连接，初始化 c w n d为 1 个报文段， s s t h re s h为 6 5 5 3 5 个字节。
2 ) T C P 输出例程的输出不能超过 c w n d和 接 收 方 通 告 窗 口 的 大 小 。 拥 塞 避 免 是 发 送 方 使 用 的流量控制，
而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估 计，而后者则与接收方在该连接上的可用缓存大小有关。
3) 当 拥 塞 发 生 时 ( 超 时 或 收 到 重 复 确 认 )， 
s s t h re s h被设置为当前窗口大小的一半( c w n d 和接收方通告窗口大小的最小值，但最少为 2个报文段)。
此外，如果是超时引起了拥塞，则 c w n d 被设置为 1 个 报 文 段 ( 这 就 是 慢 启 动 )。
4) 当新的数据被对方确认时，就增加 c w n d ， 但 增 加 的 方 法 依 赖 于 我 们 是 否 正 在 进 行 慢 启 动或拥塞避免。
如果 c w n d小于或等于 s s t h re s h， 则 正 在 进 行 慢 启 动 ， 否 则 正 在 进 行 拥 塞 避 免 。
慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止(因为我们记录了在步骤 2 中给我们制造麻烦的窗口大小的一半)，然后转为执行拥塞避免。


慢 启 动 算 法 初 始 设 置 c w n d 为 1 个 报 文 段 ， 此 后 每 收 到 一 个 确 认 就 加 1 。正如 2 0 . 6 节 描 述 的那样，
这会使窗口按指数方式增长:发送 1个报文段，然后是 2个，接着是 4个⋯⋯。
拥 塞 避 免 算 法 要 求 每 次 收 到 一 个 确 认 时 将 c w n d 增加 1 / c w n d 。 与 慢 启 动 的 指 数 增 加 比 起 来 ，
这 是 一 种 加 性 增 长 ( a d d i t i v e i n c r e a s e ) 。 
我 们 希 望 在 一 个 往 返 时 间 内 最 多 为 c w n d 增加 1 个报文段 ( 不 管 在 这 个 R T T 中 收 到 了 多 少 个 A C K )，
然 而 慢 启 动 将 根 据 这 个 往 返 时 间 中 所 收 到 的 确 认 的个数增加 c w n d 。




快速恢复算法
由于我们不知道一个重复的 A C K是 由 一 个 丢 失 的 报 文 段 引 起 的 ， 还 是 由 于 仅 仅 出 现 了 几 个报文段的重新排序，
因此我们等待少量重复的 A C K到 来 。 假 如 这 只 是 一 些 报 文 段 的 重 新 排 序 ， 则 在 重 新 排 序 的 报 文 段 被 处 理 并 产 生 
一 个 新 的 A C K 之 前 ， 只 可 能 产 生 1 ~ 2 个重复的 A C K 。 如果一连串收到 3个或 3 个以上的重复 A C K ，
就非常可能是一个报文段丢失了(我们在 2 1 . 5节 中见到过这种现象)。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。
这就 是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。












