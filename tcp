time_wait :在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）
为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？
主要有两个原因：
1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，
2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。
你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》


Nagle算法
该算法要求一个 T C P 连 接 上 最 多 只 能 有 一 个 未 被 确 认 的 未 完 成 的 小 分 组 ， 在 该 分 组 的 确 认到达之前不能发送其他的小分组。
相反， T C P 收 集 这 些 少 量 的 分 组 ， 并 在 确 认 到 来 时 以 一 个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发 送得越快。
而在希望减少微小分组数目的低速广域网上，则会发送更少的分组(我们将在2 2 . 3 节 看 到 “ 小 ” 的 含 义 是 小 于 报 文 段 的 大 小 )。


慢启动
该 算 法 通 过 观 察 到 新 分 组 进入网络的速率应该与另一端返回确认的速率相同而进行工作。
慢 启 动 为 发 送 方 的 T C P 增 加 了 另 一 个 窗 口 : 拥 塞 窗 口 ( c o n g e s t i o n w i n d o w ) ，记为 c w n d。
当与另一个网络的主机建立 T C P 连接时，拥塞窗口被初始化为 1 个 报 文 段 ( 即 另 一 端 通 告 的 报 文 段 大 小 )。 每 收 到 一 个 A C K ，
拥 塞 窗 口 就 增 加 一 个 报 文 段 ( c w n d 以 字 节 为 单 位 ， 但 是 慢 启 动 以报文段大小为单位进行增加)。
发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥 塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。
发送方开始时发送一个报文段，然后等待 A C K 。当收到该 A C K 时，拥塞窗口从 1 增加为 2 ， 即 可 以 发 送 两 个 报 文 段 。
当 收 到 这 两 个 报 文 段 的 A C K时 ， 拥 塞 窗 口 就 增 加 为 4 。 这 是 一 种 指 数 增加的关系


对每个连接， T C P 管理 4 个不同的定时器
1) 重传定时器使用于当希望收到另一端的确认。
2) 坚持 ( p e r s i s t ) 定 时 器 使 窗 口 大 小 信 息 保 持 不 断 流 动 ， 即 使 另 一 端 关 闭 了 其 接 收 窗 口 。
3) 保活 ( k e e p a l i v e ) 定时器可检测到一个空闲连接的另一端何时崩溃或重启。
4) 2MSL定时器测量一个连接处于 TIME_WAIT状态的时间。
