time_wait :在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）
为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？
主要有两个原因：
1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，
2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。
你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》


Nagle算法
该算法要求一个 T C P 连 接 上 最 多 只 能 有 一 个 未 被 确 认 的 未 完 成 的 小 分 组 ， 在 该 分 组 的 确 认到达之前不能发送其他的小分组。
相反， T C P 收 集 这 些 少 量 的 分 组 ， 并 在 确 认 到 来 时 以 一 个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发 送得越快。
而在希望减少微小分组数目的低速广域网上，则会发送更少的分组(我们将在2 2 . 3 节 看 到 “ 小 ” 的 含 义 是 小 于 报 文 段 的 大 小 )。
