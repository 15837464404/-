kafka技术内幕读书笔记

模块：
    producer，consumer，broker。
    producer，consumer 对于 broker来说都是客户端，通过NetworkClint 进行网络通信，producer，consumer 端均采用select模型进行网络收发。
    集群的信息都存储在zk上，broker对相应的节点进行监听做相应处理。

    producer：
        对应的类：kafkaProducer。
        支持同步和异步发送。
        发送消息前需要先获取Metadata（主题对应的分区信息，包含主副本...）。
        一次可发送多个主题，多个分区，RecordAccumulator在客户端对消息缓存。
        只和分区的主副本建立连接，可以合并同一主副本的所有分区一起发送。

    consumer：
        高级api：支持自动分配分区，自动提交commitId。
        低级api：需要手动处理。
        新api：java版本api。
        消费消息前要获取Metadata。
        每个消费线程都不会分配到同一个主题的重复分区。
        分区的所有权信息记录在zk的/consumer/[group_id]/owner/[topic]/[partition_id] -> consumer_thread_id。
        触发再平衡条件：
            1：会话超时事件。
            2：消费组的子节点变化事件。
            3：主题的数据变化事件（分区的增减，主题的增减）。
        消费者再平衡步骤：
            1：关闭数据拉取线程，清空队列和消息流，提交偏移量。
            2：释放分区的所有权，删除分区中zk和消费者的所有关系。
            3：将所有分区重新分配给每个消费者，每个消费者都会得到不同的分区。
            4：将分区对应的消费者所有者关系写入zk，记录分区的所有权信息。
            5：重新启动消费者的拉取线程。
        为消费者分配分区：
            1：构建消费者的分配上下文，得到订阅主题的分区和所有消费者线程。
            2：分区分配算法计算每个主题分区和消费者线程的映射关系。
            3：从步骤2的全局分配结果中获取属于当前消费者的分区信息。
            4：读取当前分区在zk中的最新消费进度，即它所拥有的分区偏移量。
            5：构造PartitionTopicInfo，加入到表示消费者的主题注册信息的topicRegistry中。
            6：更新TopicRegistry，后面的拉取线程会使用该结构。


    Coordinator：
        consumer: ConsumerCoordinator
        broker: GroupCoordinator
        消费者在拉取消息前要保证：
            1：确保已经连接协调者，即找到服务端中管理这个消费者的协调节点。
            2：确保已经分配到分区，即获取协调节点分配给消费者的分区信息。
        加入组请求：
            1：加入消费组之前需要先提交偏移量，执行监听器回调。
            2：消费者创建加入组请求，包含消费者的元数据作为请求数据。
            3：消费者发送加入组请求，通过组合模式返回一个新的异步请求对象，并定义回调处理器。
            4：客户端轮询，确保组合模式返回的异步请求必须完成，这是一个阻塞方法。
            5：异步请求完成，执行回调方法，将分区设置到消费者的订阅状态，并重置心跳。
        延迟操作：
            协调者处理不同消费者的加入组请求由于不能立即返回加入组响应，因此会创建一个延迟操作，表示协调者会延迟发送加入组响应给消费者。
            但协调者不会为每个消费者的"加入组请求"创建一个"延迟操作"，而是仅当消费组状态从 "稳定" 转变为 "准备再平衡" 时才创建一个 "延迟操作" 对象。

            延迟操作需要指定一个超时事件，超时后强制完成。存储在超时缓存中。创建完成后会执行一次tryComplete，返回true，则执行onComplete。否则加入cache，
            当相关事件发生时继续调用tryComplete。

            加入组请求的延迟操作是否可以完成的判断标准是：
                消费组元数据的notYetRejoinedMembers（）返回是否为null，这个方法收集的是消费组中awaitingJoinCallback值对象为null的消费者元数据，
                因为协调者一旦开始处理消费者发送的加入组请求，就会设置awaitingJoinCallback的值。

            消费者分配分区的过程是一次重平衡的过程。

        消费组的状态机：
            稳定 ：主消费者发送同步组请求后 由 等待同步  转换为  稳定。
            准备再平衡： 稳定  创建 "延迟操作" 后 转换为  准备再平衡，  等待同步 状态下主消费者还没发送"同步组请求"，先收到了新消费者的加入组请求，
                 此时会创建一个 "延迟操作" ，然后 转换为  准备再平衡。
            等待同步：完成延迟操作后由  准备再平衡 转换为  等待同步。

            无论是从 稳定 到 准备再平衡 ，还是从 等待同步 到 准备再平衡，只要进入 再平衡状态 都会创建一个 "延迟操作"。


    log：
       每个分区对应一个主副本，N个副副本，每个副本对应一个log文件，包含数据文件和索引文件（稀疏索引），每个log文件会切分成多个logSegment。
       客户端只能拉取最高水位（HW）之前的消息，副副本可以拉取nextOffset之前消息，同时所有副本会更新HW。
       消息会根据配置刷新到文件。每条消息有唯一的递增偏移量。
       由独立线程完成。
       清理日志：
           删除：超过日志阈值，直接删除整段日志。
           压缩：相同key只保留最新值。
           删除点（墓碑标记）：如果一个带有key的消息内容是null，表示这条删除消息所在偏移量之前的所有消息都要删除，包括该消息。

       可以通过request.required.acks配置项设置需要多少副本应答才算发送成功，-1表示所有副本。


    Controller：
        选举：
            所有broker都会尝试创建/controller节点，创建成功者为主控制器，其他watch该节点。
        分区状态机：
            新建，在线，下线，不存在。
            不存在不能直接到上线，要按时序操作。
            正常的状态机流程是  不存在 -> 新建 -> 上线 -> 下线 ，也可以 新建 -> 下线。
            分区存在主副本时转换为上线。
        副本状态机：
            新建，在线，下线，不存在。

        分区信息：
            leadId ，AR，ISR 。
        发送信息：
            LeaderAndIsr：只会发送给分区相关的副本所在的broker。
            UpdateMetaData：发送给所有broker，包含所有主题信息。
            StopReplica：删除主题时发送，不带删除标记时副本状态转换为 下线 ，带删除标记时转换为  开始删除。
        _Consumer_offsets:
            默认分区50个。
            保存两种数据：
                1：消费者提交的偏移量：key为GroupTopicPartition，值为消费者提交的偏移量。
                2：消费组分配的状态数据：key为消费组编号，值为分配给每个消费组的分区结果。


